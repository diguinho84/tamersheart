<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="style.css"/>
</head>

<script>

    //variaveis
    var canvasHeight;
    var canvasWidth;
    var ctx;

    var coordX = 0;
    var coordY = 0;
    var moveDireita = 0;
    var moveEsquerda = 0;
    var moveCima = 0;
    var moveBaixo = 0;
    var player = 0;

    var teclaPressionada;
    var teclaLiberada;

    var elementosMapa = [];


    //classes
    class Quadrado {

      constructor(x, y, width, height){
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        // this.xm = x + (width/2);
        // this.ym = y + (height/2);
      }

      getXm(){ return this.x + (width/2) }
      getYm(){ return this.x + (width/2) }
      getPontoMedio(){ return {xm: getXm(), ym: getYm()} }
    
    }

    class Circulo{

      constructor(x, y, raio){
        this.x = x;
        this.y = y;
        this.raio = raio;
        // this.raio = raio,
        // this.center = {x: this.x, y: this.y}
      }

      getCenter(){ return {x: this.x, y: this.y} }
      getRaio(){ return this.raio; }
    }

    // class Ponto{

    //   constructor( x, y){

    //     this.x = x,
    //     this.y = y
    //   }
    // }
    
    class Player{

      constructor(obj){
        this.x = obj.x;
        this.y = obj.y;
        this.width = obj.width;
        this.height = obj.height;
        // this.xm = this.x + (this.width/2);
        // this.ym = this.y + (this.height/2);
        // this.quadrado = new Quadrado(this.x, this.y, this.width, this.height),
        // this.circulo = new Circulo(this.x , this.y, 
        //   dist( new Ponto(this.x, this.y), new Ponto(this.xm, this.ym) ) )
      }

      moveX(dist, intensidade){
        this.x = this.x + dist * (intensidade ? intensidade : 1);
      }

      moveY(dist, intensidade){
        this.y = this.y + dist * (intensidade ? intensidade : 1);
      }

      getXm(){ return this.x + (this.width/2) }
      getYm(){ return this.x + (this.width/2) }
      getPontoMedio(){ return {xm: this.getXm(), ym: this.getYm()} }
      getRaio(){ return raio( (this.width/2) , (this.height/2) ) }
      getCirculo(){ return new Circulo(this.x, this.y, this.getRaio())}
    }




    
//#region Init Settings
function initCanvasContextSettings(){

    canvasHeight = document.getElementById("canvas").getAttribute("height");
    canvasWidth = document.getElementById("canvas").getAttribute("width");
    ctx = document.getElementById("canvas").getContext("2d");
}

function init(){

  //varaives padrao canvas
  initCanvasContextSettings();

  //inicializa o player, talvez os demais elementos e players
  player = new Player({x: 10, y:150, width:10, height:10});

  elementosMapa[0] = new Player({x: 50, y:150, width:10, height:10})

  //starta o loop de animacao
  window.requestAnimationFrame(draw);
}
//#endregion




//#region Movimentacao logica
//sao dois sinais apenas por enquanto, down e up
function setaVetoresDirecao(player, e){

  //Seta os vetores direcao
  //Como só tem keydown ou keyup deu pra fazer o ternario
  if( e.key == "ArrowRight") {  moveDireita  = e.type == "keydown" ?  1 : 0;}
  if( e.key == "ArrowLeft")  {  moveEsquerda = e.type == "keydown" ?  1 : 0;}
  if( e.key == "ArrowUp")    {  moveCima     = e.type == "keydown" ?  1 : 0;}
  if( e.key == "ArrowDown")  {  moveBaixo    = e.type == "keydown" ?  1 : 0;}
}

function movimentacaoLogica(player){

  //Aplica os vetores direcao
  moveDireita  == 1 ? tryMove(player, "x", 1, 1)  : true ;
  moveEsquerda == 1 ? tryMove(player, "x", -1, 1) : true ;
  moveCima     == 1 ? tryMove(player, "y", -1, 1) : true ;
  moveBaixo    == 1 ? tryMove(player, "y", 1, 1)  : true ; 
}

function tryMove(player, f, u1, u2){

  var projecaoPlayer = new Player(player);
  if(f == "x"){ 
    projecaoPlayer.moveX(u1, u2);
    if(!colisao2dCirculo(projecaoPlayer.getCirculo(), elementosMapa[0].getCirculo())){
      player.moveX(u1, u2);
    }
  }
  
}

function colisao2dCirculo( bolaA, bolaB ){ 
  
  var result = dist(bolaA.getCenter(), bolaB.getCenter()) <= (bolaA.getRaio() + bolaB.getRaio())
  console.log(dist(bolaA.getCenter(), bolaB.getCenter()));
  console.log(bolaA.getRaio() + bolaB.getRaio())
  return result;
}

function dist(pontoA, pontoB){

  return Math.pow( ((pontoA.x - pontoB.x)**2 + (pontoA.y - pontoB.y)**2), 0.5 );
}
//#endregion




//#region Event Listenners e Notificacoes
  document.addEventListener("keydown", function(event) {notifica(event);});
  document.addEventListener("keyup", function(event)   {notifica(event);});
  window.addEventListener('load', init);

  function notifica(e){

    if(e.type == "keydown"){ setaVetoresDirecao(player, e)}
    if(e.type == "keyup")  { setaVetoresDirecao(player, e)}

  }
//#endregion




//#region Desenho
  function desenhaQuadrado(obj){

    ctx.fillStyle = "#aaaaaa";
    ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
  }

  function desenha(obj){

    ctx.fillStyle = "#aaaaaa";
    ctx.fillRect( obj.x, obj.y, obj.width, obj.height);
  }

  function limpaTela(){

    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
  }

  function draw() {

    movimentacaoLogica(player);

    limpaTela(); 
    desenha(player);
    desenha(elementosMapa[0]);

    window.requestAnimationFrame(draw);
  }
//#endregion




//#region Math

function raio(ladoA, ladoB){ 
  return Math.pow( ((ladoA)**2 + (ladoB)**2), 0.5 ) 
}

function distancia(A, B){

  return Math.pow( ((A.x - B.x)**2 + (A.y - B.y)**2), 0.5 )
}

//#endregion

</script>





<script>
    
    //talvez o raio medio entre o raio externo e o interno
    //facilitar o desenvolvimento, parece q se o codigo for bom deve ficar facil colocar melhorias
    //  e continuar
    //parei aqui - todos os valores abixo de height precisam ser revisados
    //colocar td no js
    //nao vai ter desempenho maximo nem rodar em td por hora
    //ver classes pra ja colocar
    //colocar contexto de posicionamento e colisao
    //contexto de bitmap
    //alguma animacao de ataque
    //se conseguir duas animacoes de atq versionar
    //rn - precisa tirar nota em provas escrita e pratia pra ir ranked
    //bug com tres teclas


    //ok - movimentacao simples, colocar pra Y e adequar classes, colisao simples
    //ok - colocar alguns objs e possivelmente uma classe

    // const element = document.querySelector("textarea"),
    //   ArrowRight = k => {
    //      console.log(k);
    //   },
    //   ArrowLeft = k => {
    //      console.log(k);
    //   },
    //   ArrowUp = k => {
    //      console.log(k);
    //   },
    //   ArrowDown = k => {
    //      console.log(k);
    //   },
    //   handler = {
    //      ArrowRight,
    //      ArrowLeft,
    //      ArrowUp,
    //      ArrowDown
    //   };
    //   element.addEventListener("keydown", e => {
    //      const k = e.key;
    //      if (handler.hasOwnProperty(k)) {
    //         handler[k](k);
    //      }
    //   });

    //nao funciona pois os valores estao no atributo inves do style
    //canvasHeight = document.getElementById("canvas").style.height;
    //canvasWidth = document.getElementById("canvas").style.width;



    //#region Logica de Codigo
    //Logica de Teclas
    ///Uma tecla qndo apertado é registrada na secao event listener, depois o notificador usa
    //a funcao adequada dependendo do tipo de evento na secao movimentacao logica
    //nisso apenas a direcao e setado, ficando a cargo do loop iterar a movimentacao toda vez 
    //por ultimo o desenho apenas pega os dados e desenha
    //#endregion


</script>



















<body>

    <p style="text-align: center;">uia</p>

    <div style="text-align: center">
        <canvas id="canvas" width="200" height="500" 
          style="border: 1px solid #c9c9c9;">
        </canvas>
    </div>


</body>
</html>



